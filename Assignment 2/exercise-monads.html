<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="" xml:lang="">
<head>
  <meta charset="utf-8" />
  <meta name="generator" content="pandoc" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
  <meta name="author" content="" />
  <title>Exercise Set 2: Monad Exercises</title>
  <style>
    code{white-space: pre-wrap;}
    span.smallcaps{font-variant: small-caps;}
    span.underline{text-decoration: underline;}
    div.column{display: inline-block; vertical-align: top; width: 50%;}
    div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
    ul.task-list{list-style: none;}
    pre > code.sourceCode { white-space: pre; position: relative; }
    pre > code.sourceCode > span { display: inline-block; line-height: 1.25; }
    pre > code.sourceCode > span:empty { height: 1.2em; }
    code.sourceCode > span { color: inherit; text-decoration: inherit; }
    div.sourceCode { margin: 1em 0; }
    pre.sourceCode { margin: 0; }
    @media screen {
    div.sourceCode { overflow: auto; }
    }
    @media print {
    pre > code.sourceCode { white-space: pre-wrap; }
    pre > code.sourceCode > span { text-indent: -5em; padding-left: 5em; }
    }
    pre.numberSource code
      { counter-reset: source-line 0; }
    pre.numberSource code > span
      { position: relative; left: -4em; counter-increment: source-line; }
    pre.numberSource code > span > a:first-child::before
      { content: counter(source-line);
        position: relative; left: -1em; text-align: right; vertical-align: baseline;
        border: none; display: inline-block;
        -webkit-touch-callout: none; -webkit-user-select: none;
        -khtml-user-select: none; -moz-user-select: none;
        -ms-user-select: none; user-select: none;
        padding: 0 4px; width: 4em;
        color: #aaaaaa;
      }
    pre.numberSource { margin-left: 3em; border-left: 1px solid #aaaaaa;  padding-left: 4px; }
    div.sourceCode
      {   }
    @media screen {
    pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
    }
    code span.al { color: #ff0000; font-weight: bold; } /* Alert */
    code span.an { color: #60a0b0; font-weight: bold; font-style: italic; } /* Annotation */
    code span.at { color: #7d9029; } /* Attribute */
    code span.bn { color: #40a070; } /* BaseN */
    code span.bu { } /* BuiltIn */
    code span.cf { color: #007020; font-weight: bold; } /* ControlFlow */
    code span.ch { color: #4070a0; } /* Char */
    code span.cn { color: #880000; } /* Constant */
    code span.co { color: #60a0b0; font-style: italic; } /* Comment */
    code span.cv { color: #60a0b0; font-weight: bold; font-style: italic; } /* CommentVar */
    code span.do { color: #ba2121; font-style: italic; } /* Documentation */
    code span.dt { color: #902000; } /* DataType */
    code span.dv { color: #40a070; } /* DecVal */
    code span.er { color: #ff0000; font-weight: bold; } /* Error */
    code span.ex { } /* Extension */
    code span.fl { color: #40a070; } /* Float */
    code span.fu { color: #06287e; } /* Function */
    code span.im { } /* Import */
    code span.in { color: #60a0b0; font-weight: bold; font-style: italic; } /* Information */
    code span.kw { color: #007020; font-weight: bold; } /* Keyword */
    code span.op { color: #666666; } /* Operator */
    code span.ot { color: #007020; } /* Other */
    code span.pp { color: #bc7a00; } /* Preprocessor */
    code span.sc { color: #4070a0; } /* SpecialChar */
    code span.ss { color: #bb6688; } /* SpecialString */
    code span.st { color: #4070a0; } /* String */
    code span.va { color: #19177c; } /* Variable */
    code span.vs { color: #4070a0; } /* VerbatimString */
    code span.wa { color: #60a0b0; font-weight: bold; font-style: italic; } /* Warning */
  </style>
  <link rel="stylesheet" href="style.css" />
  <!--[if lt IE 9]>
    <script src="//cdnjs.cloudflare.com/ajax/libs/html5shiv/3.7.3/html5shiv-printshiv.min.js"></script>
  <![endif]-->
</head>
<body>
<header id="title-block-header">
<h1 class="title">Exercise Set 2: Monad Exercises</h1>
<p class="author"></p>
</header>
<h2 id="warm-up-reader-writer-state-monads">Warm-up: Reader-Writer-State monads</h2>
<p>The Reader-Writer-State (RWS) monad encapsulates three separate pieces of state: one that can only be read, one that can only be appended to, and one that can be freely both read and written. (In applications where one of these behaviors is not relevant, we can make the corresponding data pieces be just <code>()</code>.)</p>
<p>The file <a href="https://absalon.instructure.com/files/5161846/download?download_frd=1"><code>Warmup.hs</code></a> contains skeleton definitions for the RWS monad and associated operations, as well as a variant of the RWS monad that also supports throwing errors, together with a couple of simple tests. Complete the missing parts of the definitions, and check that the provided tests complete successfully. Don’t change anything that is not explicitly marked as <code>undefined</code>.</p>
<h2 id="randomised-response">Randomised Response</h2>
<p>Randomised response is a statistical protocol that enables collecting sensitive information while protecting the privacy of the responders. The core idea is that you introduce random noise to protect the individual responders.</p>
<p>For a binary (yes/no) question the protocol is: first the responder flips a coin; if the coin shows head, then the responder gives a truthful answer (after flipping the coin again, to eliminate a side channel); if the coin shows tail, then the responder flips the coin again and gives the result as answer. Thus, when we get an answer from a responder, we don’t know if we got a random answer or a truthful answer; but the responses from a larger population will still be biased (in a statistically quantifiable way) to the truth.</p>
<p>Using the <a href="https://hackage.haskell.org/package/random"><code>System.Random</code></a> module we can write the function <code>binary_random_response</code> that implements the randomised response protocol:</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true"></a><span class="kw">import</span> <span class="kw">qualified</span> <span class="dt">System.Random</span> <span class="kw">as</span> <span class="dt">R</span></span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true"></a></span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true"></a><span class="ot">binary_random_response ::</span> <span class="dt">R.StdGen</span> <span class="ot">-&gt;</span> <span class="dt">Bool</span> <span class="ot">-&gt;</span> (<span class="dt">Bool</span>, <span class="dt">R.StdGen</span>)</span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true"></a>binary_random_response g true_answer <span class="ot">=</span></span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true"></a>  <span class="kw">if</span> first_coin <span class="kw">then</span> (true_answer, g&#39;)</span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true"></a>  <span class="kw">else</span> R.random g&#39;</span>
<span id="cb1-7"><a href="#cb1-7" aria-hidden="true"></a>  <span class="kw">where</span> (first_coin, g&#39;) <span class="ot">=</span> R.random g</span></code></pre></div>
<p>Where the user should call <code>binary_random_response</code> with a random number generator (initially, for example, <code>R.mkStGen 42</code>) and the truthful answer as arguments, and then submit the boolean returned as result.</p>
<p><strong>Warm-up exercise:</strong> Actually, the given <code>binary_random_response</code> function doesn’t quite implement the protocol correctly. It has introduced a side-channel (the protocol specifies that the coin should always be flipped twice, but the program only sometimes calls <code>R.random</code> twice). Correct the implementation.</p>
<p><strong>Generalise exercise:</strong> Implement a function <code>random_response</code> that works for multiple-choice questions. That is, <code>random_response</code> should have the type:</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true"></a><span class="ot">random_response ::</span> <span class="dt">R.StdGen</span> <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> [a] <span class="ot">-&gt;</span> (a, <span class="dt">R.StdGen</span>)</span></code></pre></div>
<p>The first <code>a</code> represents the truthful answer, while the <code>[a]</code> is the list of possible answers. The result should be either (with probability 1/2) the true answer, or a random answer from the list.</p>
<p><strong>Use monads exercise:</strong> In the previous functions it’s somewhat cumbersome and error-prone to thread the random number generator around. To simplify the code we can use a monad.</p>
<ul>
<li>Which monad should we use?</li>
<li>Rewrite your functions to use monadic style using the <code>do</code>-notation.</li>
</ul>
<h1 id="you-could-have-invented-monads">You could have invented Monads</h1>
<p>The following two exercises are a rewording/ripoff of the exercises from Dan Piponi’s blog post <a href="http://blog.sigfpe.com/2006/08/you-could-have-invented-monads-and.html">You Could Have Invented Monads! (And Maybe You Already Have)</a>, go there if you want solutions, more exercises, and longer explanations.</p>
<h2 id="traceable-functions">Traceable functions</h2>
<p>Define a monad for working with <em>traceable functions</em>. That is, functions that compute both a result and a trace of their computation. For instance, a normal function that takes a floating-point number and computes a new floating-point number will have the type:</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb3-1"><a href="#cb3-1" aria-hidden="true"></a><span class="ot">f ::</span> <span class="dt">Float</span> <span class="ot">-&gt;</span> <span class="dt">Float</span></span></code></pre></div>
<p>but a traceable function should have a type more like:</p>
<div class="sourceCode" id="cb4"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb4-1"><a href="#cb4-1" aria-hidden="true"></a><span class="ot">ft ::</span> <span class="dt">Float</span> <span class="ot">-&gt;</span> (<span class="dt">Float</span>, <span class="dt">String</span>)</span></code></pre></div>
<p>Thus, if we have the two traceable functions <code>ft</code> and <code>gt</code> we can then compose them, and compute the composed trace with code:</p>
<div class="sourceCode" id="cb5"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb5-1"><a href="#cb5-1" aria-hidden="true"></a><span class="kw">let</span> (y, s) <span class="ot">=</span> gt x</span>
<span id="cb5-2"><a href="#cb5-2" aria-hidden="true"></a>    (z, t) <span class="ot">=</span> ft y <span class="kw">in</span> (z, s<span class="op">++</span>t)</span></code></pre></div>
<p>But keeping track of the trace like this is quite cumbersome, instead we would like use the <code>do</code>-notation:</p>
<div class="sourceCode" id="cb6"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb6-1"><a href="#cb6-1" aria-hidden="true"></a><span class="kw">do</span> y <span class="ot">&lt;-</span> gt x</span>
<span id="cb6-2"><a href="#cb6-2" aria-hidden="true"></a>   z <span class="ot">&lt;-</span> ft y</span>
<span id="cb6-3"><a href="#cb6-3" aria-hidden="true"></a>   <span class="fu">return</span> z</span></code></pre></div>
<p>Define a monad for working with traceable functions. That is, complete the following code:</p>
<div class="sourceCode" id="cb7"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb7-1"><a href="#cb7-1" aria-hidden="true"></a><span class="kw">newtype</span> <span class="dt">Trace</span> a <span class="ot">=</span> <span class="dt">T</span> (a, <span class="dt">String</span>)</span>
<span id="cb7-2"><a href="#cb7-2" aria-hidden="true"></a></span>
<span id="cb7-3"><a href="#cb7-3" aria-hidden="true"></a><span class="kw">instance</span> <span class="dt">Monad</span> <span class="dt">Trace</span> <span class="kw">where</span></span>
<span id="cb7-4"><a href="#cb7-4" aria-hidden="true"></a>    <span class="co">-- (&gt;&gt;=) :: Trace a -&gt; (a -&gt; Trace b) -&gt; Trace b</span></span>
<span id="cb7-5"><a href="#cb7-5" aria-hidden="true"></a>    (<span class="dt">T</span> p) <span class="op">&gt;&gt;=</span> f <span class="ot">=</span> <span class="op">...</span></span>
<span id="cb7-6"><a href="#cb7-6" aria-hidden="true"></a></span>
<span id="cb7-7"><a href="#cb7-7" aria-hidden="true"></a>    <span class="co">-- return :: a -&gt; Trace a</span></span>
<span id="cb7-8"><a href="#cb7-8" aria-hidden="true"></a>    <span class="fu">return</span> x <span class="ot">=</span> <span class="op">...</span></span></code></pre></div>
<p>For testing your code you might want to use the following utility function for constructing traceable functions for normal functions:</p>
<div class="sourceCode" id="cb8"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb8-1"><a href="#cb8-1" aria-hidden="true"></a><span class="ot">traceable ::</span> <span class="dt">String</span> <span class="ot">-&gt;</span> (t <span class="ot">-&gt;</span> a) <span class="ot">-&gt;</span> t <span class="ot">-&gt;</span> <span class="dt">Trace</span> a</span>
<span id="cb8-2"><a href="#cb8-2" aria-hidden="true"></a>traceable name f <span class="ot">=</span> \x <span class="ot">-&gt;</span> <span class="dt">T</span>(f x, name <span class="op">++</span><span class="st">&quot; called.&quot;</span>)</span></code></pre></div>
<h2 id="multivalued-functions">Multivalued Functions</h2>
<p>Consider the the functions <code>sqrt</code> and <code>cbrt</code> that compute the square root and cube root, respectively, of a real number. These are straightforward functions of type:</p>
<div class="sourceCode" id="cb9"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb9-1"><a href="#cb9-1" aria-hidden="true"></a><span class="dt">Float</span> <span class="ot">-&gt;</span> <span class="dt">Float</span></span></code></pre></div>
<p>(although <code>sqrt</code> will throw an exception for negative arguments, something we’ll ignore).</p>
<p>Now consider a version of these functions that works with complex numbers. Every complex number, except zero, has two square roots. Similarly, every non-zero complex number has three cube roots. So we’d like <code>sqrtC</code> and <code>cbrtC</code> to return lists of values. In other words, we’d like</p>
<div class="sourceCode" id="cb10"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb10-1"><a href="#cb10-1" aria-hidden="true"></a>sqrtC,<span class="ot"> cbrtC ::</span> <span class="dt">Complex</span> <span class="dt">Float</span> <span class="ot">-&gt;</span> [<span class="dt">Complex</span> <span class="dt">Float</span>]</span></code></pre></div>
<p>We’ll call these <em>multivalued</em> functions.</p>
<p>Suppose we want to find the sixth root of a real number. We can just concatenate the cube root and square root functions. In other words we can define <code>sixthroot</code> as follow:</p>
<div class="sourceCode" id="cb11"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb11-1"><a href="#cb11-1" aria-hidden="true"></a>sixthroot x <span class="ot">=</span> <span class="fu">sqrt</span> (cbrt x)</span></code></pre></div>
<p>But how do we define a function that finds all six sixth roots of a complex number using <code>sqrtC</code> and <code>cbrtC</code>. We can’t simply concatenate these functions. What we’d like is to first compute the cube roots of a number, then find the square roots of all of these numbers in turn, combining together the results into one long list. That is, by using <code>do</code>-notation we can define <code>sixthrootC</code> as:</p>
<div class="sourceCode" id="cb12"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb12-1"><a href="#cb12-1" aria-hidden="true"></a><span class="ot">sixthrootC ::</span> <span class="dt">Complex</span> <span class="dt">Float</span> <span class="ot">-&gt;</span> [<span class="dt">Complex</span> <span class="dt">Float</span>]</span>
<span id="cb12-2"><a href="#cb12-2" aria-hidden="true"></a>sixthrootC x <span class="ot">=</span> <span class="kw">do</span></span>
<span id="cb12-3"><a href="#cb12-3" aria-hidden="true"></a>   cr <span class="ot">&lt;-</span> cbrtC x</span>
<span id="cb12-4"><a href="#cb12-4" aria-hidden="true"></a>   sr <span class="ot">&lt;-</span> sqrtC cr</span>
<span id="cb12-5"><a href="#cb12-5" aria-hidden="true"></a>   <span class="fu">return</span> sr</span></code></pre></div>
<p>We have rediscovered the list monad. Try to define it for yourself, by completing the implementation:</p>
<div class="sourceCode" id="cb13"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb13-1"><a href="#cb13-1" aria-hidden="true"></a><span class="kw">newtype</span> <span class="dt">Multivalued</span> a <span class="ot">=</span> <span class="dt">MV</span> [a]</span>
<span id="cb13-2"><a href="#cb13-2" aria-hidden="true"></a></span>
<span id="cb13-3"><a href="#cb13-3" aria-hidden="true"></a><span class="kw">instance</span> <span class="dt">Monad</span> <span class="dt">Multivalued</span> <span class="kw">where</span></span>
<span id="cb13-4"><a href="#cb13-4" aria-hidden="true"></a>    <span class="co">-- (&gt;&gt;=) :: Multivalued a -&gt; (a -&gt; Multivalued b) -&gt; Multivalued b</span></span>
<span id="cb13-5"><a href="#cb13-5" aria-hidden="true"></a>    (<span class="dt">MV</span> p) <span class="op">&gt;&gt;=</span> f <span class="ot">=</span> <span class="op">...</span></span>
<span id="cb13-6"><a href="#cb13-6" aria-hidden="true"></a></span>
<span id="cb13-7"><a href="#cb13-7" aria-hidden="true"></a>    <span class="co">-- return :: a -&gt; Multivalued a</span></span>
<span id="cb13-8"><a href="#cb13-8" aria-hidden="true"></a>    <span class="fu">return</span> x <span class="ot">=</span> <span class="op">...</span></span>
<span id="cb13-9"><a href="#cb13-9" aria-hidden="true"></a></span>
<span id="cb13-10"><a href="#cb13-10" aria-hidden="true"></a>sqrtC, cbrtC,<span class="ot"> sixthrootC ::</span> <span class="dt">Complex</span> <span class="dt">Float</span> <span class="ot">-&gt;</span> <span class="dt">Multivalued</span> (<span class="dt">Complex</span> <span class="dt">Float</span>)</span>
<span id="cb13-11"><a href="#cb13-11" aria-hidden="true"></a><span class="op">...</span></span></code></pre></div>
<hr />
<h2 id="work-sheet-generation">Work-sheet Generation</h2>
<p>When kids are learning maths in primary school it’s custom to give them work-sheets with lots of problems to practice on. We use the type <code>Problem</code> for representing a practice problem that mixes addition and multiplication of integers:</p>
<div class="sourceCode" id="cb14"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb14-1"><a href="#cb14-1" aria-hidden="true"></a><span class="kw">type</span> <span class="dt">Problem</span> <span class="ot">=</span> (<span class="dt">Expr</span>, <span class="dt">Int</span>)</span>
<span id="cb14-2"><a href="#cb14-2" aria-hidden="true"></a><span class="kw">data</span> <span class="dt">Expr</span> <span class="ot">=</span> <span class="dt">Const</span> <span class="dt">Int</span></span>
<span id="cb14-3"><a href="#cb14-3" aria-hidden="true"></a>          <span class="op">|</span> <span class="dt">Plus</span> <span class="dt">Expr</span> <span class="dt">Expr</span></span>
<span id="cb14-4"><a href="#cb14-4" aria-hidden="true"></a>          <span class="op">|</span> <span class="dt">Mult</span> <span class="dt">Expr</span> <span class="dt">Expr</span></span>
<span id="cb14-5"><a href="#cb14-5" aria-hidden="true"></a>          <span class="kw">deriving</span> (<span class="dt">Show</span>, <span class="dt">Read</span>, <span class="dt">Eq</span>)</span></code></pre></div>
<p>That is, a <code>Problem</code> is a pair of an arithmetic expression and the value it evaluates to (the later is used for generating a grading sheet for the teacher). Normally, the problem would be presented to the student in conventiona infix notation with minimal parentheses, like in <code>showCompact</code> from Assignment 1, but that is not relevant to this exercise.</p>
<p><strong>Worksheet exercise:</strong> Write a function <code>generate_sheet</code> that can generate a list of <em>n</em> random practice problems of “difficulty” <em>d</em>. The number <em>d</em> controls, in some suitable way, both the maximal size (or depth) of the expression, and the magnitude of the constants occurring in it. For example, for <em>n</em>=2 and <em>d</em>=3, it could return</p>
<div class="sourceCode" id="cb15"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb15-1"><a href="#cb15-1" aria-hidden="true"></a>[(<span class="dt">Plus</span> (<span class="dt">Const</span> <span class="dv">2</span>) (<span class="dt">Const</span> <span class="dv">217</span>), <span class="dv">219</span>),</span>
<span id="cb15-2"><a href="#cb15-2" aria-hidden="true"></a> (<span class="dt">Mult</span> (<span class="dt">Const</span> <span class="dv">4</span>) (<span class="dt">Plus</span> (<span class="dt">Const</span> <span class="dv">11</span>) (<span class="dt">Const</span> <span class="dv">2</span>)), <span class="dv">52</span>)]</span></code></pre></div>
<ul>
<li>What is the full type of <code>generate_sheet</code> (including the machinery for random-number generation)?</li>
<li>You might want to start by writing a function <code>eval</code> that can evaluate an arithmetic expression. (Why?)</li>
</ul>
</body>
</html>
